pub fun input(prompt: Text): Text {
    unsafe $printf "\${nameof prompt}"$
    unsafe $read$
    return "$REPLY"
}

pub fun replace_once(source, pattern, replacement) {
    return unsafe $echo "\$\{source/{pattern}/{replacement}}"$
}

pub fun replace(source, pattern, replacement) {
    return unsafe $echo "\$\{source//{pattern}/{replacement}}"$
}

pub fun replace_regex(source: Text, pattern: Text, replacement: Text): Text {
    return unsafe $echo "{source}" | sed -e "s/{pattern}/{replacement}/g"$
}

pub fun dir_exist(path) {
    $[ -d "{path}" ]$ failed {
        return false
    }
    return true
}

pub fun file_exist(path) {
    $[ -f "{path}" ]$ failed {
        return false
    }
    return true
}

pub fun file_read(path) {
    return $cat "{path}"$?
}

pub fun file_write(path, content) {
    return $echo "{content}" > "{path}"$?
}

pub fun file_append(path, content) {
    return $echo "{content}" >> "{path}"$?
}

pub fun split(text: Text, delimiter: Text): [Text] {
    let result = [Text]
    unsafe $IFS="{delimiter}" read -ra {nameof result} <<< "\${nameof text}"$
    return result
}

pub fun lines(text: Text): [Text] {
    let result = [Text]
    unsafe $IFS=\$'\n' read -rd '' -a {nameof result} <<<"\${nameof text}"$
    return result
}

pub fun words(text: Text): [Text] {
  return split(text, " ")
}

pub fun join(list: [Text], delimiter: Text): Text {
    return unsafe $IFS="{delimiter}" ; echo "\$\{{nameof list}[*]}"$
}

pub fun trim_left(text: Text): Text {
    return unsafe $echo "{text}" | sed -e 's/^[[:space:]]*//'$
}

pub fun trim_right(text: Text): Text {
    return unsafe $echo "{text}" | sed -e 's/[[:space:]]*\$//'$
}

pub fun trim(text: Text): Text {
    return trim_left(trim_right(text))
}

pub fun lower(text: Text): Text {
    return unsafe $echo "{text}" | tr '[:upper:]' '[:lower:]'$
}

pub fun upper(text: Text): Text {
    return unsafe $echo "{text}" | tr '[:lower:]' '[:upper:]'$
}

#[allow_absurd_cast]
pub fun len(value): Num {
    unsafe {
        if value is Text:
            return $echo "\$\{#{nameof value}}"$ as Num
        else:
            return $echo "\$\{#{nameof value}[@]}"$ as Num
    }
}

#[allow_absurd_cast]
pub fun parse(text: Text): Num {
    $[ -n "{text}" ] && [ "{text}" -eq "{text}" ] 2>/dev/null$?
    return text as Num
}

pub fun chars(text: Text): [Text] {
    let chars = [Text]
    unsafe $for ((i=0; i<\$\{#{nameof text}}; i++)); do
        {nameof chars}+=( "\$\{{nameof text}:\$i:1}" );
    done;$
    return chars
}

#[allow_absurd_cast]
pub fun sum(list: [Num]): Num {
    return unsafe $echo "{list}" | awk '\{s=0; for (i=1; i<=NF; i++) s+=\$i; print s}'$ as Num
}

pub fun has_failed(command: Text): Bool {
    unsafe silent $eval {command}$
    return status != 0
}

pub fun exit(code: Num): Null {
    unsafe $exit "{code}"$
}

pub fun includes(arr, value) {
    loop v in arr {
        if v == value {
            return true
        }
    }
    return false
}

// MATH MODULE

pub fun PI(): Num {
    return 3.141592653589793;
}

pub fun is_int(x: Num): Bool {
    return (x % 1 == 0);
}

pub fun floor(x: Num): Num {
    if (x % 1 == 0) {
        return x;
    }
    return (x - (x % 1));
}

pub fun ceil(x: Num): Num {
    if (x % 1 == 0) {
        return x;
    }
    if (x < 0) {
        return (x - (x % 1));
    }
    return (x + (1 - (x % 1)));
}

pub fun round(x: Num): Num {
    if (x % 1 == 0) {
        return x;
    } if (x < 0) {
        return (x + 0.5 - ((x + 0.5) % 1)) - 1;
    }
    return (x + 0.5 - ((x + 0.5) % 1));
}

pub fun abs(x: Num): Num {
    let result = x;
    if (x < 0) {
        result = x*-1;
    }
    return result;
}

pub fun sign(x: Num): Num {
    let result = 0;

    if {
        (x > 0) {
            result = 1;
        }
        (x < 0) {
            result = -1;
        }
    }
    return result;
}

pub fun min(x: Num, y: Num): Num {
    let result = x;
    if (y < x) {
        result = y;
    }
    return result;
}

pub fun max(x: Num, y: Num): Num {
    let result = x;
    if (y > x) {
        result = y;
    }
    return result;
}

pub fun pow(base: Num, exponent: Num): Num {
    let result = 1;

    if (exponent < 0) {

        let divider = 1;
        loop i in 0..abs(exponent) {
            divider = divider * base;
        }
        result = 1 / divider;

    } else {

        loop i in 0..exponent {
            result = result * base;
        }

    }
    return result;
}

pub fun sqrt(x: Num): Num {
    if (x < 0) {
        return 0;
    } else {
        let result = x;
        let last = 0;
        loop {
            last = result;
            result = (result + x / result) / 2;
            if (result == last) {
                break;
            }
        }
        return result;
    }
}

pub fun log(x: Num, precision: Num): Num {
    if (x <= 0) {
        return 0;
    }
    let sum = 0;
    let width = (x - 1) / precision;

    loop i in 1..precision {
        sum += width / (1 + (i - 0.5) * width);
    }

    return sum;
}

pub fun log10(x: Num, precision: Num): Num {
    if (x <= 0) {
        return 0;
    }

    let sum = 0;
    let width = (x - 1) / precision;
    let log10 = log(10, precision);

    loop i in 1..precision {
        sum += width / (log10 * (1 + (i - 0.5) * width));
    }

    return sum;
}

pub fun exp(x: Num, precision: Num): Num {
    let result = 1;
    let term = 1;

    loop i in 1..precision {
        term = term * x / i;
        result += term;
    }

    return result;
}

pub fun sin(x: Num, precision: Num): Num {
    let radians = (x * PI()) / 180;
    let result = radians;
    let term = radians;

    loop i in 1..precision {
        term = term * (radians * -1) * radians / ((2 * i) * (2 * i + 1));
        result += term;
    }

    return result;
}

pub fun cos(x: Num, precision: Num): Num {
    let radians = (x * PI()) / 180;
    let result = 1;
    let term = 1;

    loop i in 1..precision {
        term = term * (radians * -1) * radians / ((2 * i - 1) * (2 * i));
        result += term;
    }

    return result;
}

pub fun tan(x: Num, precision: Num): Num {
    return sin(x, precision) / cos(x, precision);
}
